<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML - notatki</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <main>
        <header>
          <h1>Notatki z HTML-a</h1>
        </header>
    
        <section>
          <h2>MODUŁ </h2>
          <article>
            <h4>Zasady</h4>
            <ol>
              <li>Baw się dobrze</li>
              <li>Wycisz wszystkie powiadomienia</li>
              <li>Oglądaj uważnie</li>
              <li>Rób notatki</li>
              <li>Nie pomijaj odcinków</li>
              <li>Bądź częścią społeczności</li>
              <li>Działaj regularnie:<ul>
                  <li>Zrób notatki na podstawie prezentacji</li>
                  <li>Obejrzyj lekcje</li>
                  <li>Sprawdź prace domowe</li>
                  <li>Obejrzyj jeszcze raz przy wykonywaniu zadań</li>
                </ul>
              </li>
            </ol>
          </article>
        </section>
        <footer>
          Brudnopis Angeliki Borko - notatki z frontendu.
        </footer>
      </main>


Nauka HTML-a
HTML - tydzień 2
HTML - podstawowe informacje i znaczniki
HTML – nie jest to język programowania, lecz język znaczników (HyperText Markup Language) ; odpowiada za semantykę, nadaje znaczenie i strukturę elementom składającym się na treść strony.
Tworzymy główny plik – index.html. Po utworzeniu pliku wpisujemy w pierwszej linii ”!” i klikamy tabulator. Automatycznie wkleja nam się wówczas podstawowa struktura dokumentu html.
Obecnie obowiązujący standard to HTML 5, który stał się tzw. living standard, czyli zmienianym ewolucyjnie, a nie w ramach nowych edycji.

DOCTYPE – określa typ dokumentu, aktualnie będzie to raczej zawsze html
Lang – wybór języka, np. en, pl; ma znaczenie dla dostępności, kierują się tym czytniki treści
"head" to co jest w tej sekcji nie jest widoczne na stronie, ale wpływa na jej wygląd i treść
"main" główna treść dokumentu,
"header" główny nagłówek dokumentu, sekcji lub artykułu (dodawany np. w przypadku artykułów na blogu i zawierający wówczas nazwisko autora czy datę,
"footer" stopka dokumentu, sekcji lub artykułu,
"section" sekcja dokumentu, część treści logicznie wyodrębniona; każda sekcja powinna mieć nagłówek,
"article" część treści, która może funkcjonować jako odrębny element (analogia do gazety – sekcja to np. sekcja kulturalna, a article to konkretny artykuł w ramach takiej sekcji,
"h1-h6" nagłówki od najważniejszego do najmniej istotnego,
"p" paragraf, akapit
Wszystko to zawiera się w "body", a potem w "main".
ctrl+shift+p i wyszukiwana fraza „format” – z podpowiedzi wybieramy „format document” i automatycznie formatuje nam dokument napisany w html.
Możemy też regulować wyrównywanie, głębokość wcięć. Wybieramy w tym celu opcję "spaces" na dolnej belce VSC po prawej stronie, następnie na rozwijanej liście klikamy w opcję indent using tabs i wpisujemy wybraną wartość (wybrałam 2, wcześniej było 4). To samo można zastosować w pliku ze stylami.

Kod HTML ma strukturę drzewa, rodziny, klanu z zagnieżdżonymi elementami, które zawierają się jedne w drugich w relacji rodzic (element, w którym jest zagnieżdżony inny element) - dziecko (element, który jest zagnieżdżony w innym elemencie, swoim rodzicu). Poszczególne zagnieżdżone elementy to węzły (node), a element, z którego wychodzą to korzeń (root element - znacznik html).

HTML - tydzień 3
Znaczniki wyróżniające treść
"znacznik atrybut="wartość""treść"/znacznik"
br - znacznik pozwalający na przejście do nowej linii. Po dodaniu go na końcu frazy, po której chcemy rozpocząć nową linię, kolejna część tekstu zaczyna się w nowej linii. Jest to znacznik występujący pojedynczo, nie ma swojej pary, tzw. znacznik samozamykający. Można go jednak zapisać też tradycyjnie poprzez rozpoczęcie i zamknięcie znacznika na końcu danej frazy, po której chcemy zacząć nową llinię. Ale najlepiej zapisać go po prostu w nawiasach ostrych jako "br/".
b (bold) - wyróżnienie wizualne tekstu z otaczającej go treści poprzez pogrubienie, nie ma żadnego znaczenia semantycznego,
i (italic) - wyróżnienie wizualne tekstu z otaczającej go treści poprzez kursywę, nie ma żandego znaczenia semantycznego,
strong - wyróżnia wizualnie tekst poprzez pogrubienie, ale ma również znaczenie semantyczne, służy podkreśleniu znaczenia danej frazy,
em - wyróżnia wizualnie tekst poprzez kursywę, ale ma również znaczenie semantyczne, służy podkreśleniu, że dany zwrot został użyty w innym znaczeniu niż dosłowne, często ironicznie.

Linkowanie i nawigacja
a - znacznik używany do tworzenia linków zewnętrznych oraz łacza wewnątrz dokumentu, opisywany jest najczęsciej przez dwa atrybuty - href i target.
"a href="" target="""opis łącza"/a"
Tworząc link zewnętrzny jako wartość atrybutu href podajemy adres strony, do której chcemy się odwołać, np. href="https://cotenfrontend.pl", a w opisie łącza wskazujemy dokąd link prowadzi (będzie to literał, który będzie linkował do przestrzeni zewnętrznej).
Tworząc łącze w ramach dokumentu musimy posłużyc się atrybutem "id" identyfikującym dany element, np. daną sekcję, header, etc. Identyfikator powinien być unikalny w ramach dokumentu (id="moj-identyfikator") i odnosimy się do niego podając na początku jego wartości znak #. Czyli jeśli danemu elementowi nadamy id o wartości "notatki", to odnosimy się do niego wpisując href="#notatki". ważne jest też, m. in. z punktu widzenia dostępności strony, by w opisie łącza wskazywać dokładnie, dokąd link prowadzi. Przykładowo, jeśli w elemencie header damy id="top", to w stopce możemy stworzyć łącze pozwalające na powrót na górę strony wyglądające w ten sposób: href="#top" i jako opis łącza podać "Wróć na górę strony".

nav - służy do nawigacji, np. między podstronami w ramach dokumentu; wskazuje, że jest to główna nawigacja po stronie/serwisie.
Aby utworzyć kolejne podstrony, tworzymy kolejny plik, np. nauka-html.html (nie używamy znaków diakrytcznych ani spacji, rozdzielamy myślinikami). Kopiujemy całą treść z pliku index.html i zaczynamy porządki. Na początku tworzymy dodatkowy znacznik header, który znajduje się w body, ale poza znacznikiem main. Dzięki temu na wszystkich podstronach będzie powtarzał się ten sam nagłówek. Każdą treść powtarzalną wyrzucamy poza main, czyli oprócz znacznika header może to być przykładowo znacznik footer. Treści takie nie są analizowane przez wyszukiwarki czy czytniki treści, które skupiają się na treści zawartej w tagu main.
W takim znaczniku header znajdującym się poza tagiem main, wpisujemy tag nav i w ramach tego znacznika, stosując znaczniki a, dodajemy linkowanie do podstron, tworząc w ten sposób spis treści. Jako adres podajemy nazwę pliku podstrony, do której linkujemy, czyli np. href="nauka-html.html". Dobrą praktyką jest, by menu się powtarzało, czyli zawierało takie same linki na wszystkich podstronach, co oznacza, że na podstronie "strona główna" powinien być również link do strony głównej. Przy przeklikiwaniu między stronami widać, że zmienia się adres w urlu - na index lub nauka-html.
Elementem powtarzalnym jest również stopka, więc wycnamy ją na obu dokumentach z sekcji main i wklejamy poza tym znacznikiem. Sam nagłówek h1 w header w sekcji main zostawiamy w obu dokumentach, tylko zmieniamy jego treść w pliku nauka-html.html, tak aby odpowiadał treści na tej podstronie, czyli np. "Nauka HTML-a". Robimy też roszady w treści dokumentów.

Dodawanie obrazków na stronie
img scr="" alt=""
img - znacznik, który pozwala na dołączenie obrazka, który ma podany adres
Aby dodać obrazek, zapisujemy go w formacie np. jpg lub gif w folderze naszego projektu. Jest on wówczas widoczny również wśród plików wyświetlonych w edytorze kodu. Następnie wybieramy miejsce, gdzie chcemy taki obrazek dodać - ja postanowiłam dodać stworzony przeze mne obrazek przedstawiający przykład schematu blokowego w notatce na ten temat w pliku nauka-js.html. Obrazek znajduje się na tej podstronie.

W pliku tym w miejscu, gdzie chcemy dodać obrazek, otwieramy znacznik img i wskazujemy adres obrazka, podając jego nazwę, w moim przypadku to src="schemat-blokowy.JPG". Dodajemy też tekst alternatywny jako wartość dla atrybutu "alt". Tekst ten nie jest widoczny dla użytkownika na stronie, ale posługują się nim wyszukiwarki oraz mające na celu zapewnienie dostępności czytniki stron internetowych. Warto więc w miarę dokładnie opisać zawartość obrazka. W moim przypadku to alt="Krótki schemat blokowy na przykładzie akcji czytania książki."
Img jest znacznikiem samozamykającem się (tak jak br), więc na koniec dajemy tylko slash i zamykamy nawias ostry.
W ramach pracy domowej mam dodać obrazki na każdej stronie, więc poniżej Magdusia radośnie ucząca się frontendu.
      </article>
<Article>Strona główna Nauka HTML Nauka CSS Nauka JavaScriptu Nauka - varia
  Nauka CSS-a
  CSS - tydzień 2
  CSS - podstawowe informacje i selektory, kolory
  CSS – Cascading style sheets – odpowiada za prezentację, wygląd treści. Każdy język ma swoją składnię, w przypadku CSS są to reguły, mające następującą budowę:
  selektor {
  właściwość: wartość;
  }
  
  Style co do zasady definiuje się w osobnym pliku o rozszerzeniu .css, ale można je też zdefiniować w pliku html w sekcji "head" poprzez dodanie znacznika "style", gdzie definiujemy właściwości poszczególnych elementów, odnosząc się do nich za pomocą selektorów, którymi mogą być nazwy tych elementów (np. h1, p), np.:
  p {
  color: green;
  }
  
  Sposobów zapisu kolorów jest kilka, np. angielska nazwa, zapis heksadecymalny, czyli w systemie szestnastkowym - #xxyyzz, gdzie xx to kanał czerwony, yy to kanał zielony, a zz to kanał niebieski. Style określa się jednak najczęściej w zewnętrznym arkuszu stylów, a w samym pliku html zawiera się do niego odnośnik poprzez odpowiednia frazę – znacznik "link" o odpowiedniej składni. Kolejną własnością, obok koloru, jest tło. Można je określić dla całej strony wskazując jako selektor "body", czyli np.:
  body {
  background: lightyellow;
  }
  
  Możemy zaprojektować paletę kolorystyczną naszej strony posiłkując się generatorem coolors
  
  CSS - tydzień 3
  Stylowanie w oparciu o atrybuty element, id i klasa
  Oprócz tego, że style można zamieścić w ramach znacznika style w sekcji "head" lub w pliku zewnętrznym, mozna je też zastosować używając atrybutu "style" i przypisując go do konkretnego znacznika, np. section, h1, p, etc. wg schematu:
  znacznik style="color:yellow; background:#ffffff;" treść /znacznik
  Styl przy znaczniku z wykorzystaniem atrybutu "style" nazywamy stylem inline, liniowym. Znajduje on zastosowanie jedynie do tego konkretnego znacznika, przy którym atrybut ten został wpisany.
  Aplikowanie stylów w ten sposób nie ma jednak większego sensu, bo robi się bałagan - kod staje się nieczytelny i trudny do modyfikacji. I tutaj właśnie w grę wchodzą tzw. prawdziwe selektory - wcześniej stylowaliśmy odnosząc się do elementów, natomiast najlepiej to robić w oparciu o identyfikatory i klasy: #id i .class. Zwłaszcza klasy, które dodaje się do znaczników wg schematu:
  znacznik class="name" treść /znacznik
  Atrybut .class dodajemy w html przy danych tagach/znacznikach (pozwala na pogrupowanie elementów), natomiast przekłada się on na stylowanie i cssy. Nazwę, którą nadajemy danej klasie, tworzymy wg schematu kebab-case. Aby ostylować elementy, które mają przypisaną daną klasę, odnosimy się do nich w pliku ze stylami w następujący sposób:
  .name {
  właściwość: wartość;
  }
  .(kropka) - to selektor klasy
  
  Do stylowania elementów można wykorzystać również id, które wcześniej nadaliśmy tagom po to, by wykorzystać je jako kotwicę służącą do przenoszenia sie w ramach dokumentu do konkretnej sekcji. Identyfikator nadaje się elementom i wykorzystuje do stylowania wg następującego schematu:
  znacznik id="name" treść /znacznik
  #name {
  właściwość: wartość;
  }
  # (hash) - to selektor id
  Na danej stronie dokumentu może znajdować się tylko jedno id o danej konkretnej wartości, przypisane do jednego konkretnego elementu.
  
  Selektory można łączyć, czyli do danego znacznika może byc przypisane konkretne id i określona klasa.
  Jeśli chcemy ostylować wg określonego wzoru wszystkie linki, które znajdują się w obszarze nawigacji "nav", tak by stylowanie odróżniało je od pozostałych linków występujących w treści dokumentu. Elementy o znaczniku "a" są zatem zagnieżdżone w znaczniku "nav", chcemy więc ostylować elementy znajdujące się w innym elemencie. Odnosimy się do nich w pliku z cssami wpisując po sobie elementy "nav" i po spacji "a" wg wzoru:
  nav a {
  własność: wartość1;
  }
  a {
  własność: wartość2;
  }
  Przy takim zapisie style nie zaaplikują się do samego znacznika "nav", ale do zawartych w nim elementów "a", gdzie dana własnośc będzie miała wartość1. Natomiast pozostałe elementy "a", które nie są zagnieżdżone w "nav" przyjmą wartość2 dla tej własności. Odnosząc się do elementów "a" zawartych w "nav" nie musimy więc podawać dokładnej ścieżki body>header>nav, wystarczy podanie bezpośredniego rodzica, czyli "nav". Nie musi to być również bezpośredni rodzic - w tym przypadku ten sam efekt osiągniemy wpisując ścieżkę header>a.
  
  !important i specyficzność w CSS
  !important to zmora, jeśli chodzi o stylowanie. Nie powinno się tego używać, ponieważ !important dopisany przy wartości dla danej własności opisującej określony element sprawia, że styl, przy którym został on dodany nadpisuje wszystkie inne style, które zostały zdefiniowane dla danego elementu. Opierając się na wcześniejszym przykładzie rozróżnienia stylów linków zagnieżdżonych w znaczniku "nav" oraz linków znajdujących sie poza tym znacznikiem w treści dokumentu, dodanie "!important" przy własności zdefiniowanej dla linków niezagnieżdżonych sprawia, że wszystkie linki, zagnieżdżone i niezagnieżdżone, zostaną ostylowanie zgodnie z tym stylem. Przykład takiego zapisu:
  nav a {
  własność: wartość1;
  }
  a {
  własność: wartość2 !important;
  }
  Wstawienie importanta w jakimś miejscu może więc sprawić, ze stylowanie całej strony się pozypie. Zatem jeśli nie musimy i zastosowanie importanta nie jest naprawdę celowe w danym przypadku, to go nie używajmy.
  
  Co w sytuacji, gdy do danego elementu mamy zdefiniowane stylowanie zarówno w pliku css, jak i przy danym znaczniku jako inline, tak jak na poniższym przykładzie?
  W pliku CSS mamy zapis:
  #name {
  color: red;
  }
  Natomiast w kodzie html przy danym elemencie mamy wstawiony inline:
  span id="name" style="color: yellow" treść /span
  Dla treści elementu span o id=name mamy więc zdefiniowany w pliku css kolor czerwony, natomiast w stylu liniowym kolor żółty. Przeglądarka zastosuje tutaj styl zdefiniowany w inline, czyli treść będzie miała kolor żółty.
  Jest to przykład występowania specyficzności w CSS, czyli zasad ważności sposobów zastosowania stylów w sytuacji, gdy są one w konflikcie. Specificity to zatem zasada, która określa który selektor ma pierwszeństwo w przypadku, kiedy wiele z nich ustawia te same reguły CSS dla tego samego znacznika HTML. Kolejność ta została zwizualizowana na poniższym obrazku.
  
  Obrazek przedstawiający kolejność zastosowania selektorów: important, inline, id, klasa, element.
  Zastosowanie ma zatem następująca kolejność wg pierwszeństwa obowiązywania reguł wprowadzonych przez selektory: important, inline, id, klasa, element. Przy czym dwa pierwsze, important i inline, są stosowane rzadko, dlatego zostały ujęte w nawiasie.
  Przykładowo, jeśli mamy zdefiniowane dwie reguły css dla znacznika h1 w taki sposób jak poniżej, czyli w jednej z nich jako selektor podajemy sam pojedynczy znacznik h1, natomiast w drugiej uwzględniamy zagnieżdżenie tego znacznika h1 w elemencie body (jako selektor podajemy dwa elementy - dziecko i rodzica), to w opierając się na zasadach specificity, zastosowanie będzie miała reguła CSS zdefiniowana w oparciu o selektor z dwoma elementami (bo dwa elementy to więcej niż jeden element).
  h1 {
  color: red;
  }
  body h1 {
  color: yellow;
  }
  Nagłówek będzie zatem żółty, ponieważ reguła CSS definiująca ten styl ma wyższą specyficzność. Poniżej znajduje się obrazek przedstawiający wizualizację tego przykładu.
  
  Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy.
  To, która z reguł CSS będzie miała zastosowane jest również widoczne w devtools w przeglądarce - styl, który został nadpisany jest przekreślony. Przekreślone są również zwykle domyślne style przeglądarki, gdy są nadpisywane przez nas. W tym przypadku nie są przekreślone, bo taka własność nie została zdefiniowana w przeglądarce (zadziałoby się tak np. w przypadku stylów zdefiniowanych dla linków). Poniżej zrzut ekranu z devtools dla omawianego przypadku.
  
  Zrzut ekranu z devtools przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy.
  Devtools pozwala też na dodanie w zakładce elements do znacznika body atrybutu "contenteditable", poprzez kliknięcie prawym przyciskiem i wybór opcji add atribute. Po dodaniu atrybutu można na żywo edytować stronę z poziomu jej widoku, a nie narzędzi w devtools.
  
  Kolejnym przykładem zastosowania reguł specyficzności css jest sytuacja, gdy do danego nagłówka zostały użyte reguły css, z których jedna styluje go w oparciu o selektor składający się z trzech elementów, natomiast druga używa selektora w postaci id.
  html body h1 {
  color: yellow;
  }
  #main-header {
  color: red;
  }
  Wyższą specyficzność będzie miała tu reguła definiująca kolor czerwony. Mimo tego, że kolor żółty opiera sie na selektorze składającym się z trzech elementów, a kolor czerwony określany jest dla selektora składającego sie z jednego id, to id ma większą wagę i pierwszeństwo w zasadach specyficzności. Wizualizację tego przykładu zawiera poniższy obrazek.
  
  Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor trójelementowy, a druga selektor id.
  Na kolejnym przykładzie mamy sytuację, gdy jeden ze stylów zdefiniowany jest w oparciu o id i trzy elementy, natomiast drugi w oparciu o id, klasę i jeden element. Wyższą specyficzność będzie miała reguła CSS bazująca na id, klasie i jednym elemencie, ponieważ zawiera więcej selektorów o wyższej wadze - id i klasa (2). Można to też przeczytać jako całe liczby i w ten sposób 111 > 103, a zatem nagłówek będzie miał kolor czerwony. Poniżej zapis kodu i obrazek, który ilustruje ten przykład.
  html body h1 #main-header {
  color: yellow;
  }
  body .section #main-header {
  color: red;
  }
  
  Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o id i trzy elementy, a druga w oparciu o selektor id, klasę i jeden element.
  Jeśli specyficzność jest równa, to pierwszeństwo ma selektor znajdujący się "bliżej" elementu.
  Przykładowo w jednym pliku style.css mamy zdefiniowane dwie reguły składające się z tych samych selektorów, lecz każda z tych reguł styluje dany element w inny sposób. I jedna z reguł znajduje się pod drugą w treści pliku, przy czym reguła definiująca kolor czerwony znajduje się wyżej niż reguła stylująca kolor niebieski. Zastosowanie będzie miała tu reguła stylująca kolor niebieski, czyli ta, która jest niżej, ponieważ znajduje się ona bliżej stylowanego elementu.
  body section#main h1.heading {
  color: red;
  }
  body section#main h1.heading {
  color: blue;
  }
  
  Aby unaocznić sobie, na czym polega ta bliskość, wyobrażamy sobie, że style zdefiniowane w pliku style.css są umieszczone w pliku HTML w miejscu, gdzie znajduje się odniesienie do pliku css. Na przykładzie zobrazowanym poniżej element header ma przypisaną klasę "styl1", w oparciu o którą został ostylowany w pliku css, gdzie dla tej samej reguły określono dwa różne style. Zastosowany zostanie styl definiujący kolor niebieski, ponieważ jest umieszczony niżej, a tym samym fizycznie znajduje się bliżej elementu header.
  
  Zrzut ekranu przedstawiający, na czym polega bliskość stylowanego elementu reguły znajdującej sie niżej w pliku.
  Analogicznie wygląda sytuacja, jeśli wpiszemy w pliku style.css dwa style w jeden selektor, np.:
  body section#main h1.heading {
  color: red;
  color: blue;
  }
  Pierwszeństwo będzie miał ten, który jest niżej, czyli w tym przypadku niebieski.
  
  Rekomendowane jest dodawanie klas do wszystkich elementów (nawet jeśli mamy tylko jeden element danego typu) i unikanie zagnieżdżeń przy stylowaniu (np. selektorów składających się z kilku elementów).
  
  Można przyjąć następujące wytyczne dla tworzenia nazw klas:
  1. Używamy pojedynczych angielskich słów rozpoczynających się od małej litery, a jeśli jest konieczne użcie dwóch słów, to stosujemy kebab-case.
  2. Nie zaczynamy od cyfry.
  3. Nazywamy rzeczy zgodnie z ich funkcją na stronie.
  4. Nie zwiększamy specyficzności bez potrzeby - staramy się, by element miał jedną klasę.
  <article>

  Strona główna Nauka HTML Nauka CSS Nauka JavaScriptu Nauka - varia
Nauka JavaScriptu
JavaScript - tydzień 2 i 3
Podstawy
JAVA SCRIPT – umożliwia interakcje

ECMAScript - skryptowy język oprogramowania, ustandaryzowany przez organizację ECMA, ECMAScript Language Specification.
ECMA - European Association for Standardizing Information and Communication Systems jest to organizacja, której zadaniem jest tworzenie standardów technologicznych.
Co roku jest aktualizowany, w kursie wykorzystywany ES6+ dla roku 2015+ i nowszych, do 2020 włącznie. JavaScript implementuje rzeczy ze specyfikacji ECMAScript. Nowo wprowadzone feature'y, funkcje języka, mogą nie być wspierane we wszystkich przeglądarkach, ale można to obejść.

JavaScript jest obiektowym językiem programowania i składa się z następujących elementów:
- wartości, 
- zmienne,
- funkcje,
- literały,
- obiekty,
- operacje porównywania.

Wartości są dla JS tym, czym liczby dla matematyki - jest to pewien zbiór, który już istnieje, nie tworzymy go. Wartością może być np. jakaś liczba, słowo. Są one niezmienialne.

Pliki zawierające kod JavaScript mają rozszerzenie .js. Podobnie jak style mają też swój znacznik "script".
Znacznik "script" dodajemy na samym dole strony, po stopce "footer", tuż przed domknięciem znacznika "body".
Przykładem może być funkcja alert, która składa się z nazwy funkcji, nawiasów otwartych oraz znajdujących się w nawiasie parametrów w pojedynczych apostrofach. Na końcu dajemy średnik ; oznaczający zakończenie linii.
Przedstawienie umiejscowienia znacznika script z funkcją alert przed domknięciem znacznika body.
Skrypt wykonuje się tylko raz, jeszcze przed załadowaniem strony. W przypadku funkcji alert jest to wyskakujące okienko zawierające treść podaną w parametrach funkcji.

Przykład działania funkcji alert na stronie - wyskakujące okienko.
Tak, jak w przypadku stylów, bezpośrednie pisanie kodu JavaScript w pliku z htmlem zadziała, ale jest mało praktyczne, dlatego stosuje się wydzielanie kodu JavaScript do osobnego pliku, np. main.js.
W pliku zawieramy po prostu bezpośrednio treść naszego kodu JavaScript w kolejności, w jakiej ma być wykonywany.
Odniesienie do pliku z kodem JavaScript umieszczamy na końcu strony przed domknięciem znacznika body, używając znacznika "script". Używamy atrybutu "src", tak jak w obrazkach, a nie "href", tak jak w przypadku stylów.

Odwołanie do pliku z kodem JavaScript w pliku HTML.
Kolejnym poleceniem jest funkcja console.log, która w przeciwieństwie do funkcji alert nie wyświetla informacji na stronie, ale w narzędziach deweloperskich w zakładce "console".
Funkcja console.log pozwala na wyśietlenie określonego tekstu lub wartości, np.:
console.log('tekst');
Jeśli wpisze się funkcję dwa razy, to zostanie ona wywołana dwukrotnie.

Przykład dwukrotnego wywołania funkcji console.log w konsoli w narzędziach deweloperskich w przeglądarce.
Zmienna w JavaScript to stworzenie powiązania między nazwą, której chcemy użyć a wartością, którą chcemy przypisać tej zmiennej.
const name = 'Magdusia';
const age = 38;
Zmiennej o nazwie "name" przypisujemy wartość słowną "Magdusia", używając apostrofów. Zmiennej o nazwie "age" przypisujemy wartość liczbową "38", nie używając apostrofów.
Przy tworzeniu zmiennych nie trzeba dawać średnika na końcu linii, przeglądarka to przetworzy. Jednak dla dobrej praktyki lepiej to robić, żeby zaznaczyć w ten sposób koniec linii.
Wywołując nazwę zmiennej w funkcji nie używamy apostrofów.
Stworzenie zmiennej słownej i liczbowej oraz ich wywołanie w funkcji console.log.

Backtick/backquote (`) - przetrącony apostrof, na klawiaturze znajduje się tam, gdzie tylda ~.
Używamy go, jeśli chcemy wykorzystać w jakiejś funkcji jednocześnie zmienną i tekst - taki ciąg znaków nazywamy literałem.
console.log(`Nazywam się ${firstName} i mam ${age} lat.`);

Wykorzystanie w funkcji console.log jednocześnie zmiennej oraz tekstu, czyli literału.
Kod Js uruchamia się raz (po załadowaniu strony). Może też oczywiście działać później, jeśli ma odpowiednie instrukcje.

Strona domowa Magdaleny Derek, wszystkie treści są wynikiem nauki w ramach szkolenia WTF: Co ten frontend. Wróć na górę strony
</article>
<article>Strona główna Nauka HTML Nauka CSS Nauka JavaScriptu Nauka - varia
  Nauka - pozostałe tematy
  
  Varia - tydzień 2
  Schemat blokowy
  Zapis kroków/instrukcji, które powinny się po sobie wydarzać to algorytmy. Algorytm można zapisać za pomocą schematu blokowego.
  Prostokąt – wykonywane akcje
  Romb – sprawdzany warunek – w zależności od odpowiedzi wykonujemy inną akcję
  Trapez – rzeczy, które trzeba przygotować przed rozpoczęciem akcji, warunki rozpoczęcia
  Okręgi – start i stop – rozpoczęcie i zakończenie algorytmu
  
  Krótki schemat blokowy na przykładzie akcji czytania książki.
  Devtools – narzędzia developerskie w przeglądarce.
  
  Varia - tydzień 3
  Nazywanie rzeczy
  Wymyślając nazwy, które stosujemy w programowaniu, należy stosować się do następujących zasad:
  1. Nie używamy znaków diakrytycznych.
  2. Nie używamy spacji.
  3. Stosujemy angielskie nazwy (rekomendacja, a nie wymóg).
  4. Trzymamy się konsekwentnie jednego, wybranego schematu.
  
  Stosuje się następujące konwencje nazewnictwa:
  1. camelCase - całą frazę piszemy łącznie, gdy składa się z kilku słów, to pierwsze rozpoczynamy z małej litery, wszystkie kolejne natomiast rozpoczynamy wielką literą, np. id "my super bod header" zgodnie z tą konwencją zostałby zapisany w następujacy sposób: mySuperBoldHeader.
  2. kebab-case - wszystkie słowa występujące w danej frazie piszemy z małej litery i rozdzielamy je myślnikiem, np. id "my super bod header" zgodnei z tą konwencją zostałby zapisany w następujacy sposób: my-super-bold-header.
  3. snake_case - wszystkie słowa występujące w danej frazie piszemy z małej litery i rozdzielamy je podkreślinikiem, np. id "my super bod header" zgodnei z tą konwencją zostałby zapisany w następujacy sposób: my_super_bold_header.
  4. PascalCase - wywodzi się z języka Pascal; całą frazę piszemy łącznie, gdy składa się z kilku słów, to zarówno pierwsze pierwsze słowo, jak i kolejne rozpoczynamy z wielkiej litery, np. id "my super bod header" zgodnie z tą konwencją zostałby zapisany w następujacy sposób: MySuperBoldHeader.
  W praktyce najczęściej wykorzystuje się dwa pierwsze sposoby zapisu, czyli camelCase i kebab-case.
  
  Działanie przeglądarki
  HTTP (HTTPS) - protokół, z którego zazwyczaj korzysta przeglądarka, żeby pobrać pliki występujace na stronach, a następnie wyświetlić je użytkownikowi. HTTP - HyperText Transfer Protocol, a zatem HTTP to protkół do transferowania HTML-a i całej reszty widocznej na stronach internetowych.
  Z kolei HTTPS - Hypertext Transfer Protocol Secure to protokół szyfrowany, rekomendowany do stosowania. Zasada działania jest jednak analogiczna jak w HTTP.
  Obecnie coraz częściej wykorzystuje się protokół HTTP/2, który pozwala na tworzenie równoległych połączeń i nie blokuje tak bardzo serwera, dzięki czemu strona działa szybciej.
  
  URL - Uniform Resource Locator - adres wpisywanej strony.
  Adres strony internetowej rozbity na elementy.
  Port najczęściej nie jest widoczny, przeglądarka sama go sobie dopisuje automatycznie, gdy wykrywa, czy korzystamy z protokołu HTTP czy HTTPS. Port to informacja, w którym miejscu na serwerze znajdują się pliki. Innymi słowy, na którym porcie przeglądarka musi dogadywać się z serwerem, aby transfer doszedł do skutku.
  Ścieżka dostęu do zasobu - gdy połączymy się już z serwerem, to serwer ten szuka u siebie danego, wskazanego pliku, np. index.html. Zależnie od konfiguracji serwera, po ścieżce dostępu może być jeszcze widoczny znak zapytania oraz parametry, które są przekazywane do serwera lub mogą być one niewidoczne, a mimo to są i działają.
  
  Flow działania przeglądarki
  1. Wpisanie adresu cotenfrontend.pl.
  2. Przeglądarka szuka serwera cotenfrontend.pl. (Odpowiada za to DNS, który tłumaczy adresy pisane słownie na adresy IP).
  3. Po znalezieniu serwera, przeglądarka wypytuje go o index (jeśli podamy sam adres serwera). To, co jest indeksem zależy od konfiguracji serwera. Nie musi to być index.html, chociaż w przypadku stron statytycznych jest tak zazwyczaj (przyjęło się, że index.html to główny plik, który jest ładowany, jeśli nie podamy żadnej nazwy pliku).
  4. Serwer wysyła do przeglądarki zawartość HTML.
  5. Przeglądarka wczytuje HTML i szuka wszystkich dodatkowych zasobów: style, skrypty, obrazki, etc. i dla każdego z tych zasobów wykonuje osobne zapytanie.
  6. Przeglądarka parsuje (sprawdza składnię strony) i renderuje stronę (zamienia kod HTML na to, co widzimy, dodatkowo aplikując wszystkie style i ładując dodatkowe zasoby).
  DNS (Domain Name System) to protokół, którego główna funkcja polega na tłumaczeniu łatwych do zapamiętania przez człowieka nazw domen na zrozumiałe dla komputerów dane liczbowe.
  Serwer DNS wyszukuje adres IP danej strony na podstawie wpisu użytkownika zamieszczonego w polu adresu wyszukiwarki.
  
  Schemat komunikacji między przeglądarką i serwerem.
  Schemat komunikacji między przeglądarką i serwerem w modelu request-response.
  Komunikacja przeglądarki i serwera jest w modelu request-response, czyli przeglądarka wysyła zapytanie o dany zasób, a serwer odpowiada, że dany zasób posiada (lub nie) i przesyła odpowiednią zwrotkę. Serwer może również nie odpowiadać (wówczas dostajemy błędy) lub odpowiadać z błędem.
  
  Kody odpowiedzi protokołu HTTP
  100 - poczekaj, za chwilę dostaniesz opowiedź.
  200 - OK, serwer odpowiada, że ma taki zasób i przekazuje go przeglądarce.
  30x - przekierowania, serwer odpowiada: szukasz w złym miejscu, przekieruję Cię w dobre, bo wiem, gdzie.
  404 - nie mam tego, czego potrzebujesz, sorry.
  50x - wewnętrzne błędy serwera.
  
  Kody HTTP
  1xx - hold on
  2xx - here you go
  3xx - go away
  4xx - you fucked up
  5xx - I fucked up
  
  ROOT /
  Root to istotna część ścieżki do zasobu - mówi, wktórym miejscu przeglądarka powinna szukać danego zasobu.
  Rozróżniamy tutaj ścieżki bezwzględne, gdzie na początku adresu zasobu jest podany znak /, oraz ścieżki względne, gdzie na początku adresu zasobu znaku / nie ma.
  
  Przedstawienie na przykładzie adresu cotenfrontend.pl, na czym polega działanie roota, gdy adres obrazka podany jest ze znakiem slash na początku i bez tego znaku.
  Gdy wchodzimy na stronę https://cotenfrontend.pl/, do doklejamy wskazany wyżej adres obrazka na końcu adresu strony i w obu przypadkach dostajemy 200, bo w efekcie mamy ten sam adres obrazka, pod którym obrazek faktycznie się znajduje.
  W pierwszym przypadku, gdy adres obrazka podany był z / na początku adresu, po doklejeniu tego adresu do adresu strony, znak / z końca adresu strony zamieniany jest przez znak / z początku adresu obrazka.
  W drugim przypadku, gdy adres obrazka podany jest bez znaku / na początku adresu, po doklejeniu adresu obrazka do adresu strony, gdzie znak / znajduje się na końcu adresu, dostajemy pełny adres obrazka.
  
  Przedstawienie na przykładzie podstrony domeny cotenforntend.pl, na czym polega działanie roota, gdy adres obrazka podany jest ze znakiem slash na początku i bez tego znaku.
  Jeśli natomiast wejdziemy na podstronę o adresie https://cotenfrontend.pl/podstrona/, to w pierwszym przypadku, mając informację o znaku / na początku adresu obrazka, będzie on doklejony do końca adresu strony, czyli zapytanie pójdzie pod właściwy adres i obrazek zostanie pobrany.
  W drugim przypadku z kolei, gdy w adresie obrazka nie ma znaku /, to nastąpi próba doklejenia adresu obrazka do znaku / na końcu podstrony w podanym adresie zerwera i w efekcie nastąpi próba szukania obrazka w miejscu, w którym go nie ma.
  Tworząc stronę uruchamianą z dysku (tak, jak teraz) lepiej jednak pomijać używanie slasha na początku adresów zasobów.
  
  Terminal
  W Windowsie wchodzimy do terminala poprzez komendę cmd wpisaną w wyszukiwarce systemowej i wybieramy wiersz poleceń.
  Podstawowe polecenia:
  dir - wyświetla wszystko, co jest w bieżącym katalogu;
  cd - wyświetla ścieżkę bieżącego katalogu;
  cd (change directory) - powoduje przejście w wybrane miejsce, np do głównego katalogu (cd C:/); jeśli zaczniemy wpisywać nazwę katalogu w ścieżce, to po kliknięciu w TAB, system zacznie dopełniać nam ją podpowiedziami z danej lokalizacji;
  cd .. - powoduje przejście do katalogu wyżej;
  cd ../.. - powoduje przejście dwa katalogi wyżej;
  mkdir nowyfolder - tworzy w bieżącej lokalizacji nowy katalog o nazwie "nowyfolder";
  code . - otwiera visual studio code w bieżącym katalogu;
  code katalog - otwiera folder katalog" w visual studio code;
  cls - czyści historię bieżących poleceń w terminalu.
  Do skakania po wprowadzonych poleceniach, by wprowadzić w nowej linii ich zawartość, można używać strzałek góra/dół.
  
  Podstawowe komendy dla terminala w systemie Windows.
  Varia - tydzień 4
  GIT
  GIT narzędzie kontroli wersji kodu, wersjonowania kodu, stworzone przez Linusa Torvaldsa (tego od Linuxa). Można z niego korzystać za pomocą terminali:
  - cmd,
  - powershell,
  - git bash.
  
  Po pobraniu i zainstalowaniu GIT-a należy go skonfigurować pod nasze dane z poziomu terminala. Dostępne są następujące polecenia: git --version sprawdza wersję zainstalowanego GIT-a
  git config --global user.name "Magdalena Derek"
  git config --global user.email magdalena.derek@tlen.pl
  
  Poprawność wprowadzonych danych można sprawdzić za pomocą następujących poleceń:
  git config --get user.name
  git config --get user.email
  
  GIT składa się z repozytoriów. Repozytorium to nasz projekt, czyli katalog, w którym znajdują się wszystkie pliki, które chcemy rozwijać.
  Aby założyć repozytorium dla naszego projektu, z poziomu terminala wchodzimy do katalogu projektu (w tym przypadku katalog homepage) i używamy polecenia git init. W efekcie pojawia się informacja o utworzeniu pustego repozytorium i w katalogu homepage pojawia się nowy katalog .git, który jest katalogiem ukrytym i nie należy go kasować. W katalogu tym przechowywana jest cała historia GIT-a, informacje na temat plików. Zarządza nim program GIT, my nic tam nie robimy.
  C:\dev\homepage>git init
  Initialized empty Git repository in C:/dev/homepage/.git/
  
  Obrazek przedstawiający, na czym polega commit. Na osi czasu znajdują się punkty będące commitami z opisem zmian w projekcie.
  Commit - stan projektu na daną chwilę i opis tego, co się zmieniło od ostatniego zapisu. W commicie zapisywana jest historia zmian, czyli tylko to, co się zmieniło.
  git status - sprawdza stan plików w katalogu, w którym się znajdujemy
  git add . - opcja z kropką powoduje dodanie wszystkich plików z katalogu, w kórym się znajdujemy do śledzenia w ramach kontroli wersji kodu.
  
  Po dodaniu do śledzenia plików z katalogu, w którym się znajdujemy, kolejne zapytanie git status pokazuje jakie zmiany w plikach zostały wprowadzone i jakie pojawiły się nowe pliki, które należy skomitować.
  git commit -m "initial commit"
  Komitując zmiany, w cudzysłowiu opisujemy jakie zmiany wrzucamy w ramach tego commita. Opis może być po polsku, ale najlepiej po angielsku.
  Jako zwrotkę dostajemy informację, jakie zmiany zostały wykonane w ramach danego commita wraz z unikalnym identyfikatorem tego commita.
  
  GIT przyjmuje wszystkie rodzaje plików, ale zmiany śledzi tylko w plikach tekstowych. Nie śledzi zmian w obrazkach (i innych plikach) - jeśli takie zmiany zostały wprowadzone, to traktuje taki obrazek jako nowy plik i go po prostu podmienia, bez wskazywania konkretnych, zmienionych elementów w tym obrazku.
  
  gitk - pokazuje w nowym oknie poza terminalem historię zmian: kto, kiedy, co i w jaki sposób zmienił
  Po wprowadzeniu zmian w plikach, wpisujemy w terminalu polecenie git status, następnie git add . i komitujemy zmiany za pomoca polecenia git commit -m "description of changes", po czym sprawdzamy historię poleceniem gitk.
  
  W visual studio code jest wbudowane narzędzie, które pozwala na podglądanie repozytorium i bieżące sprawdzanie wprowadzonych zmian. Jest widoczne w edytorze w menu po lewej stronie jako trzecia ikona od góry (pod lupą) pod nazwą source control. Pokazywane są w nim zmiany wprowadzone od czasu ostatniego commita. Można również z tego narzędzia korzystać do komitowania zmian.
  
  Oprócz tego w VSC dostępne jest rozszerzenie git lens, które można dodatkowo zainstalować. Pojawi się ono wówczas jako kolejna ikona w menu po lewej stronie. Pokazywana jest tam historia wykonanych commitów i można wykonywać polecenia GIT-owe. Historia zmian wyświetlana jest dla pliku, w którym się znajdujemy aktualnie. Widoczne są też zmiany dla konkretnej linijki kodu, w której się znajdujemy.
  
  Do obsługi GIT-a można ponadto wykorzystywać całe mnóstwo programów graficznych (stanowią jakby wizualną nakładkę na GIT-a). My będziemy korzystać z narzędzia GitHub Desktop.
  
 </article>

      <article>
        <h4>2</h4>
        <p></p>
      </article>
      <article>
        <h4>3</h4>
        <p></p>
      </article>
      <article>
        <h4>4</h4>
        <p></p>
      </article>
      <article>
        <h4>5</h4>
        <p></p>
      </article>
      <h3>MODUŁ 2</h3>
      <article>
        <h4>Jak stworzyć homepage?</h4>
        <p>W Visual Studio Code, po utworzeniu pliku .html można użyć skrótu "!Tab", dzięki którem wstawia się szkielet
          strony. Strona powinna mieć różne znaczniki, dzięki którym przeglądarka oraz czytniki ekranowe będą poprawnie
          interpretować tekst.</p>
      </article>
      <article>
        <h4>Notatka kolejna</h4>
        <p>Co mam jeszcze do zrobienia/zapisania z pierwszego modułu?
          wkleje tu coś z prezki</p>
      </article>
      <article>
        <h4>Kolejna notatka</h4>
        <p>Co mam jeszcze do zrobienia/zapisania z drugiego modułu?
          wkleje tu coś z prezki</p>
      </article>
</body>
</html>